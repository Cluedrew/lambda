#ifndef STATES_EPP
#define STATES_EPP

#if 0
// Header extention for the StateMachine template.

// Edge Functions ============================================================
// Compare two Edges by their origin state and labeled transition.

    cmp (Edge const & other);
    cmp (StateT_ const & otherFrom, TransT_ const & otherBy);
    /* Compare Edges by there from and by fields for an ordering.
     * Return: -1 if this edge comes earlier, +1 if it comes later and
     *   0 if they have the same ordering.
     */

// Compare this edge against another edge.
template<typename StateT_, typename TransT_, typename PayLoadT_>
bool StateMachine<StateT_, TransT_, PayLoadT>::Edge::
    cmp (Edge const & other) const
{
  return cmp(other.from, other.by);
}

// Compare this edge against a state and transition.
template<typename StateT_, typename TransT_, typename PayLoadT_>
bool StateMachine<StateT_, TransT_, PayLoadT>::Edge::
    cmp (StateT_ const & otherFrom, TransT_ const & otherBy)
{
  if (from < otherFfrom)
    return -1;
  else if (otherFrom < from)
    return +1;
  else if (by < otherBy)
    return -1;
  else if (otherBy < by)
    return +1;
  else
    return 0;
}

#endif // 0
// StateMachine Functions ====================================================
// Check to see if a given state identifer is defined.
template<typename StateT_, typename TransT_, typename PayLoadT_>
bool StateMachine<StateT_, TransT_, PayLoadT>::isState (StateT_ state) const
{
  return states.count(state);
}

  // Attempt to add a new state with the default payload, return success.
template<typename StateT_, typename TransT_, typename PayLoadT_>
bool StateMachine<StateT_, TransT_, PayLoadT>::addState (StateT_ state)
{
  if (0 == states.count(state))
  {
    states.insert(state);
    data.insert(std::pair<StateT_, PayloadT_>(state, PayloadT_()));
    return true;
  }
  else
    return false;
}

#if 0
// Return the index of the Edge with from and by.
template<typename StateT_, typename TransT_, typename PayLoadT_>
std::vector<Edge>::size_type StateMachine<StateT_, TransT_, PayLoadT>::
    getIndex (StateT_ from, TransT_ by)

//
    getDest (StateT_ from, TransT_ by)
{
  
}
//template<typename StateT_, typename TransT_, typename PayLoadT_>
//template<typename StateT_, typename TransT_, typename PayLoadT_>
//template<typename StateT_, typename TransT_, typename PayLoadT_>

#endif//0
#endif//STATES_EPP
