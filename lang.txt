Lambda as a language:

### Scratch Pad

The defining rules make up everything to assemble the languages form, although
not its meaning, using regular rules to form tokens and a context free grammer
to create the language elements.

I am currantly having a bit of a problem with the context free porstion,
particularly how to handle the eof. A possible solution is that the eof is
never part of the rules, except that the starting symbol has the eof in its
follow set (which may trickle to other follow sets). Which can then be used
to calculate reduce operations (should never be shifted) and then when we have
just the start symbol and the eof in the look-ahead we are done.

Another solution is to 'psodo-argument' the lanuage. Argumenting the language
is (given a starting symbol S) to change the starting symbol to S' and add
a Rule S' -> bof S eof. I don't think the bof is needed but I should actually
be able to solve this problem by pretending (briefly) that the Rule '-> S eof'
is defined. That will add eof to the starting symbol's follow set and give us
a Rule by which we can shift S onto the stack. The reason for the 'non-symbol'
on the left hand side is that we never reduce to it we actually stop at the
'-> S * eof' state, never shifting on the eof or reducing the Rule.
  In short we argument the language in such a way that we don't have a special
case for 'the top' of the tree or 'the end' of the token stream. At least as
far as the user is conserned. Internally, with the addition of a 'done' shift/
reduce operation we may not need any special cases either, it would be
incorperated into the set up and run normally.

### Note: This is for the not psudo-argumented version.

### Defining Rules:
Terminal Symbols : tokens (followed by their regex)
dot .
variable [[:lower:]]
openApp (
closeApp )
eof

Non-terminal Symbols:
INPUT
PROGRAM
ELEMENT
FUNCTION
APPLICATION

Production rules:
INPUT PROGRAM
PROGRAM ELEMENT eof
ELEMENT FUNCTION
ELEMENT APPLICATION
ELEMENT variable
FUNCTION variable dot ELEMENT
APPLICATION openApp ELEMENT ELEMENT closeApp


Starting Symbol:
INPUT

### Processing:

States:
0 INPUT -> * PROGRAM
  PROGRAM -> * ELEMENT eof
  ELEMENT -> * FUNCTION
  ELEMENT -> * APPLICATION
  ELEMENT -> * variable
  FUNCTION -> * variable dot ELEMENT
  APPLICATION -> * openApp ELEMENT ELEMENT closeApp

1 INPUT -> PROGRAM *

2 PROGRAM -> ELEMENT * eof

3 PROGRAM -> ELEMENT eof *

4 ELEMENT -> FUNCTION *

5 ELEMENT -> APPLICATION *

6 ELEMENT -> variable *
  FUNCTION -> variable * dot ELEMENT

7 FUNCTION -> variable dot * ELEMENT
  ELEMENT -> * FUNCTION
  ELEMENT -> * APPLICATION
  ELEMENT -> * variable
  FUNCTION -> * variable dot ELEMENT
  APPLICATION -> * openApp ELEMENT ELEMENT closeApp

8 FUNCTION -> variable dot ELEMENT *

9 APPLICATION -> openApp * ELEMENT ELEMENT closeApp
  ELEMENT -> * FUNCTION
  ELEMENT -> * APPLICATION
  ELEMENT -> * variable
  FUNCTION -> * variable dot ELEMENT
  APPLICATION -> * openApp ELEMENT ELEMENT closeApp

10 APPLICATION -> openApp ELEMENT * ELEMENT closeApp
  ELEMENT -> * FUNCTION
  ELEMENT -> * APPLICATION
  ELEMENT -> * variable
  FUNCTION -> * variable dot ELEMENT
  APPLICATION -> * openApp ELEMENT ELEMENT closeApp

11 APPLICATION -> openApp ELEMENT ELEMENT * closeApp

12 APPLICATION -> openApp ELEMENT ELEMENT closeApp *

Shift-Reduce Operations:
0 PROGRAM shift 1
1 ? done
0 ELEMENT shift 2
0 FUNCTION shift 4
0 APPLICATION shift 5
0 variable shift 6
0 openApp shift 9
2 eof shift 3
3 - reduce (INPUT -> PROGRAM eof)
4 - reduce (ELEMENT -> FUNICTION)
5 - reduce (ELEMENT -> APPLICATION)
6 dot shift 7
6 -dot reduce (ELEMENT -> variable)
7 ELEMENT shift 8
7 FUNCTION shift 4
7 APPLICATION shift 5
7 variable shift 6
7 openApp shift 9
8 - reduce (ELEMENT -> variable dot ELEMENT)
9 ELEMENT shift 10
9 FUNCTION shift 4
9 APPLICATION shift 5
9 variable shift 6
9 openApp shift 9
10 ELEMENT shift 11
10 FUNCTION shift 4
10 APPLICATION shift 5
10 variable shift 6
10 openApp shift 9
11 closeApp shift 12
12 - reduce (APPLICATION -> openApp ELEMENT ELEMENT closeApp)

(The different values for - would be filled in from follow sets.)
